[{"content":"Redis基础 一、Redis入门 1.0 redis常识 默认端口是6379 单进程 单进程模型来处理客户端的请求。对读写等事件的响应 是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率 Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本， 它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。 默认16个数据库，类似数组下表从零开始，初始默认使用零号库，可在配置文件配置 select命令切换数据库 dbsize查看当前数据库的key的数量 flushdb：清空当前库 flushall；通杀全部库 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上 Redis索引都是从零开始 1.1Redis简介 Redis是一个基于内存的 key-value 结构数据库（内存存储）。\n基于内存存储、读写性更高 适合存储热点数据（热点商品、咨询、新闻），提高读写性能 企业应用广泛 1.2Redis启动 1.2.1 基础操作 redis-server.exe redis.windows.conf 在cmd中输入该字段来启动Redis服务。\nctrl + c : 关闭服务\nredis-cli.exe：客户端链接redis服务（本地）\nexit：退出客户端\nredis-cli.exe -h ＋ip -p + 端口号：指定链接的redis服务\n1.2.2 密码设置 打开配置文件redis.windows.conf ,然后ctrl + f 搜索 pass ，找到图片中的代码，删除注释标记，以及默认密码，更改为自己密码即可。\n再次启动redis服务后，则需要输入密码客户端才可以进行连接：redis-cli.exe -a +密码。\n二、Redis数据类型（常用） Redis存储的是key-value结构的数据，其中key是字符串类型，value由5种常用的数据类型：\n字符串：string，普通字符串 哈希：hash，也叫散列，类似java中的HashMap 列表：list，按插入顺序排序，可重复，类似java的LinkedList 集合：set，无序不可重复，类似java中的hashSet 有序集合：sorted set/zset，有序不可重复，每个元素关联一个分数，按照分数排序（升序），例如：存储排行榜信息 三、Redis常用命令(不区分大小写) 3.1 字符串类型常用命令 SET key value\t设置指定key的值 GET key\t获取指定key的值 SETEX key seconds value 设置指定key的值，并将key的过期时间设置为seconds SETNX key valuekey\t不存在时设置key的值 3.2 hash常见操作命令 HSET key field value 将哈希表 key 中的字段 field 的值设为 value HGET key field 获取存储在哈希表中指定字段的值 HDEL key field 删除存储在哈希表中的指定字段 HKEYS key 获取哈希表中所有字段 HVALS key 获取哈希表中所有值 3.3 列表常见操作命令 L\\R：代表从哪侧插入获取数据\nLPUSH key value1 [value2]\t将一个或多个值插入到列表头部 LRANGE key start stop 获取列表指定范围内的元素 RPOP key 移除并获取列表最后一个元素 LLEN key 获取列表长度 3.4集合操作常见命令 Redis set 是 string 类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令：\nSADD key member1 [member2] 向集合添加一个或多个成员 SMEMBERS key 返回集合中的所有成员 SCARD key 获取集合的成员数 SINTER key1 [key2] 返回给定所有集合的交集 SUNION key1 [key2] 返回所有给定集合的并集 SREM key member1 [member2] 删除集合中一个或多个成员 3.5有序集合操作常见命令 Redis 有序集合是 string 类型元素的集合，且不允许有重复成员。每个元素都会关联一个 double 类型的分数。常用命令：\nZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合中指定区间内的成员 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment ZREM key member [member …] 移除有序集合中的一个或多个成员 3.6通用命令 Redis 的通用命令是不分数据类型的，都可以使用的命令：\nKEYS pattern 查找所有符合给定模式 (pattern) 的 key EXISTS key 检查给定 key 是否存在 TYPE key 返回 key 所储存的值的类型 DEL key 该命令用于在 key 存在时删除 key 四、在java中操作Redis 4.1Redis的java客户端 Redis的java客户端由很多种，常见的有：\nJedis（封装优秀） Letture（性能高） Spring Data Redis(本文方法，Spring的一部分) 4.2Spring Data Redis使用方式 操作步骤：\n导入 Spring Data Redis 的 maven 坐标\n配置 Redis 数据源\n在配置文件中配置：\n1 2 3 4 5 6 spring: redis: host: localhost port: 6379 password: 3041456828 database: 0 编写配置类，创建 RedisTemplate 对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ *log*.info(\u0026#34;开始创建redis模版对象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); //设置Redis的链接工厂对象 redisTemplate.setConnectionFactory(redisConnectionFactory); //设置redis key的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 通过 RedisTemplate 对象操作 Redis 字符串操作（idea） 1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void testString(){ //set redisTemplate.opsForValue().set(\u0026#34;city\u0026#34;,\u0026#34;北京\u0026#34;); //get String city = (String)redisTemplate.opsForValue().get(\u0026#34;city\u0026#34;); System.*out*.print(city); //setex(设置有效期为3分钟) redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;,\u0026#34;1234\u0026#34;,3, TimeUnit.*MINUTES*); //setnx(非空可设置) redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); } hash操作（idea）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); //hset hashOperations.put(\u0026#34;100\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;tom\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;,\u0026#34;age\u0026#34;,\u0026#34;11\u0026#34;); //hget String name = (String)hashOperations.get(\u0026#34;100\u0026#34;,\u0026#34;name\u0026#34;); //hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.*out*.print(keys); //hvalues List values = hashOperations.values(\u0026#34;100\u0026#34;); System.*out*.print(values); //hdel hashOperations.delete(\u0026#34;100\u0026#34;,\u0026#34;age\u0026#34;); } 列表操作（idea）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void testList(){ //Lpush ListOperations listOperations = redisTemplate.opsForList(); listOperations.leftPush(\u0026#34;mylist\u0026#34;,\u0026#34;b\u0026#34;); listOperations.leftPushAll(\u0026#34;mylist\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;); //lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;,0,-1); System.*out*.print(mylist); //rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); //llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.*out*.print(size); } 集合操作（idea）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); //sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;f\u0026#34;); //smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.*out*.print(members); //scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.*out*.print(size); //sinter Set n = setOperations.intersect(\u0026#34;set1\u0026#34;,\u0026#34;set2\u0026#34;); System.*out*.print(n); //sunion Set u = setOperations.union(\u0026#34;set1\u0026#34;,\u0026#34;set2\u0026#34;); System.*out*.print(u); //srem setOperations.remove(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;); } 有序集合操作（idea）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void testZSet(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); //zadd zSetOperations.add(\u0026#34;zset1\u0026#34;,\u0026#34;a\u0026#34;,11); zSetOperations.add(\u0026#34;zset1\u0026#34;,\u0026#34;b\u0026#34;,12); zSetOperations.add(\u0026#34;zset1\u0026#34;,\u0026#34;c\u0026#34;,9); //zrange Set range = zSetOperations.range(\u0026#34;zset1\u0026#34;,0,-1); System.*out*.print(range); //zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;,\u0026#34;c\u0026#34;,10); //zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;); } } ","date":"2025-03-11T00:00:00Z","image":"https://Zq-jw.github.io/a.jpg","permalink":"https://Zq-jw.github.io/p/redis%E5%9F%BA%E7%A1%80/","title":"Redis基础"},{"content":"时空复杂度入门 前言 在算法比赛中，编程题会有时间与空间限制，在大多数情况下，时间限制以秒为单位，空间以MB为单位。\n算法题中的时间与空间限制是什么？ 简单来说，每一个题目会有很多测试点，题目要求你的代码，在每一个测试点上，既要跑得够快（时间限制），又不能占用太多内存（空间限制），否则会被判不通过。\n时间限制的意义 为什么要有时间限制？ 假设你写了一个程序，虽然结果正确，但需要运行 10 分钟才能出结果。如果考试或竞赛中大家都这么做，服务器会卡爆，所以题目会设置时间限制（比如 1 秒）。\n具体含义：\n时间限制通常以毫秒或秒为单位（比如 1 秒 = 1000 毫秒）。\n你的代码必须在规定时间内完成所有计算。\n背后的逻辑\n：代码的操作次数（比如循环、判断等）不能超过某个量级。\n例如，1 秒内大概能完成约 1 亿次（10^8）简单操作（如加减法）。 如果你的算法需要 10^12 次操作，就会超时。 常见例子：\n暴力穷举所有可能性 → 操作次数爆炸 → 超时 ❌ 用高效算法（如二分查找、哈希表） → 操作次数少 → 通过 ✅ 空间限制的意义 为什么要有空间限制？ 如果你的代码申请了一个超级大的数组（比如存 10 亿个数字），可能直接占满内存，导致程序崩溃。所以题目会限制内存（比如 256 MB）。\n具体含义：\n空间限制通常以MB为单位（比如 64MB、256MB）。\n你的代码运行时占用的内存不能超过这个值。\n背后的逻辑\n：变量、数组等数据结构的大小要合理。\n例如，一个 int 类型占 4 字节，100 万个 int 占约 4MB。 如果你声明了 1 亿个 int，会占用约 400MB → 超过 256MB 限制 → 爆内存 ❌ 常见例子：\n递归调用层数太多 → 占用栈内存 → 爆栈 ❌ 用动态规划但优化了空间 → 内存占用少 → 通过 ✅ 1. 符号的约定 在讨论算法复杂度时，我们通常使用以下符号：\n大O符号（O） 大O符号是最常见的，表示算法的上界（最坏情况）。\n写作: O(f(n)) 含义: 算法的执行时间/空间增长速度不会超过f(n) 例如: 如果一个算法的时间复杂度是O(n^2)，那么当输入规模为n时，算法最多执行c×n2c×n2步（其中cc是某个常数） 大Omega符号（Ω） 一般不考虑 表示算法的下界（最好情况）。\n写作: Ω(f(n)) 含义: 算法的执行时间/空间增长速度至少是f(n)f(n) 例如: Ω(n)表示算法至少需要与输入规模成正比的时间 大Theta符号（Θ）一般不考虑 表示算法的紧确界（平均情况）。\n写作: Θ(f(n))Θ(f(n)) 含义: 算法的执行时间/空间增长速度与f(n)f(n)相同 例如: Θ(nlog⁡n)Θ(nlogn)表示算法的执行时间/空间与nlog⁡nnlogn成正比 在实际分析中，我们最常使用大 OO 符号，因为我们通常关心算法在最坏情况下的表现。\n2. 时间复杂度 时间复杂度用于衡量算法执行所需的时间如何随着输入规模的增长而变化。\n常见的时间复杂度（从快到慢） O(1)O(1) - 常数时间 O(log⁡n)O(logn) - 对数时间 O(n)O(n) - 线性时间 O(nlog⁡n)O(nlogn) - 线性对数时间 O(n2)O(n2) - 平方时间 O(n3)O(n3) - 立方时间 O(2n)O(2n) - 指数时间 O(n!)O(n!) - 阶乘时间 2.1 常数时间复杂度 O(1)O(1) 无论输入规模多大，算法执行时间都是固定的。\n1 2 3 int getFirst(int arr[], int n) { return arr[0]; // 只执行一次，与数组大小n无关 } 2.2 对数时间复杂度 O(log⁡n)O(logn) 这个 log⁡log，在大多数情况下，都是以 22 为底，即 O(log⁡2n)O(log2n)，每一步都将问题规模缩小为原来的一部分（通常是一半）。\n二分查找示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int binarySearch(int arr[], int n, int target) { int left = 0, right = n - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; else if (arr[mid] \u0026lt; target) left = mid + 1; else right = mid - 1; } return -1; // 没找到 } 在这个例子中，每一步我们都将搜索范围缩小一半，所以复杂度是O(log⁡n)O(logn)。\n2.3 线性时间复杂度 O(n)O(n) 算法执行时间与输入规模成正比。\n顺序查找示例：\n1 2 3 4 5 6 7 int linearSearch(int arr[], int n, int target) { for (int i = 0; i \u0026lt; n; i++) { if (arr[i] == target) return i; } return -1; // 没找到 } 这个算法最坏情况下需要遍历整个数组，所以复杂度是O(n)O(n)。\n2.4 线性对数时间复杂度 O(nlog⁡n)O(nlogn) 通常出现在分治算法中，如归并排序和快速排序。\n归并排序示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void merge(int arr[], int left, int mid, int right) { // 合并两个已排序的子数组 // 这一步的复杂度是O(n) } void mergeSort(int arr[], int left, int right) { if (left \u0026lt; right) { int mid = left + (right - left) / 2; mergeSort(arr, left, mid); // 递归排序左半部分 mergeSort(arr, mid + 1, right); // 递归排序右半部分 merge(arr, left, mid, right); // 合并结果 } } 归并排序的时间复杂度是O(nlog⁡n)O(nlogn)，因为我们将数组分成两半（log⁡nlogn层）并在每一层执行O(n)O(n)的操作。\n2.5 平方时间复杂度 O(n2)O(n2) 通常出现在嵌套循环中。\n冒泡排序示例：\n1 2 3 4 5 6 7 8 9 10 11 12 void bubbleSort(int arr[], int n) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { // 交换arr[j]和arr[j+1] int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } 这个算法有两层嵌套循环，所以复杂度是O(n2)O(n2)。\n2.6 立方时间复杂度 O(n3)O(n3) 通常出现在三层嵌套循环中。\nFloyd算法（求所有点对之间的最短路径）示例：\n1 2 3 4 5 6 7 8 9 10 void floyd(int graph[MAX][MAX], int n) { for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (graph[i][k] + graph[k][j] \u0026lt; graph[i][j]) graph[i][j] = graph[i][k] + graph[k][j]; } } } } 这个算法有三层嵌套循环，所以复杂度是O(n3)O(n3)。\n2.7 指数时间复杂度 O(2n)O(2n) 通常出现在需要列举所有可能性的算法中。\n递归求解斐波那契数列（未优化）示例：\n1 2 3 4 5 int fibonacci(int n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } 这个未优化的算法时间复杂度是O(2n)O(2n)，因为对于每个nn，我们需要计算两个子问题。\n2.8 阶乘时间复杂度 O(n!)O(n!) 通常出现在需要列举全排列的算法中。\n暴力求解旅行商问题示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int tsp(int graph[MAX][MAX], int n) { // 存储所有城市 vector\u0026lt;int\u0026gt; cities; for (int i = 1; i \u0026lt; n; i++) cities.push_back(i); int min_path = INT_MAX; // 尝试所有可能的城市访问顺序 do { int current_path = 0; // 计算当前路径长度 int j = 0; for (int i = 0; i \u0026lt; cities.size(); i++) { current_path += graph[j][cities[i]]; j = cities[i]; } current_path += graph[j][0]; // 返回起点 min_path = min(min_path, current_path); } while (next_permutation(cities.begin(), cities.end())); // 求全排列 return min_path; } 这个算法需要枚举所有可能的城市访问顺序，时间复杂度为O(n!)O(n!)。\n2.9 补充：调和级数复杂度 1 2 3 4 5 6 int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = i; j \u0026lt;= n; j += i) { // 注意第二层循环 cnt ++; } } 外层循环为 nn 层，第二层循环 nii**n 次，整体为：n1+n2+n3…nn1n+2n+3n…n**n\n我们提出 nn，则为：n×(11+12+13…1n)n×(11+21+31…n1)\n该为调和级数，调和级数与 nln⁡nnlnn 同阶，可以简单理解为 O(nln⁡n)O(nlnn)。\n如何计算时间复杂度 确定基本操作：找出算法中最耗时的基本操作 计算操作次数：计算该操作执行的次数与输入规模nn的关系 去除常数和低阶项：保留增长最快的项，去掉系数 小技巧：我们通过采用循环的嵌套层数来确定时间复杂度\n例子: 计算以下代码的时间复杂度\n1 2 3 4 int sum = 0; // 执行1次 for (int i = 1; i \u0026lt;= n; i++) { // 执行n+1次 sum += i; // 执行n次 } 基本操作: 加法操作sum += i 操作次数: nn 时间复杂度: O(n)O(n) 复杂例子: 嵌套循环\n1 2 3 4 5 6 int sum = 0; // 执行1次 for (int i = 1; i \u0026lt;= n; i++) { // 执行n+1次 for (int j = 1; j \u0026lt;= i; j++) { // 执行1+2+...+n次 sum += j; // 执行1+2+...+n次 } } 内层循环执行次数: 1+2+\u0026hellip;+n=n(n+1)21+2+\u0026hellip;+n=2n(n+1) 时间复杂度: O(n2)O(n2) 3. 空间复杂度 空间复杂度用于衡量算法执行所需的额外空间如何随着输入规模的增长而变化。\n常见编程语言中的数据类型大小 数据类型 C++ (字节) Java (字节) Python 布尔型 1 1 变长 字符型 1 2 (char) 变长 整型 4 (int) 4 (int) 变长 长整型 8 (long long) 8 (long) 变长 浮点型 4 (float) 4 (float) 变长 双精度浮点 8 (double) 8 (double) 变长 指针 4/8 - - 注意：Python中的数据类型大小是动态的，而且Python的整数理论上可以无限大（只受到可用内存的限制）。\n常见的空间复杂度 O(1)O(1) - 常数空间 O(log⁡n)O(logn) - 对数空间 O(n)O(n) - 线性空间 O(n2)O(n2) - 平方空间 3.1 常数空间复杂度 O(1)O(1) 算法使用的额外空间与输入规模无关。\n1 2 3 4 5 6 7 8 9 10 int findMax(int arr[], int n) { int max_val = arr[0]; // 只使用一个变量 for (int i = 1; i \u0026lt; n; i++) { if (arr[i] \u0026gt; max_val) max_val = arr[i]; } return max_val; } 这个算法只使用了一个额外变量，空间复杂度是O(1)O(1)。\n3.2 线性空间复杂度 O(n)O(n) 算法使用的额外空间与输入规模成正比。\n1 2 3 4 5 6 7 8 9 int[] duplicateArray(int arr[], int n) { int[] result = new int[n]; // 创建一个大小为n的新数组 for (int i = 0; i \u0026lt; n; i++) { result[i] = arr[i]; } return result; } 这个算法创建了一个与输入大小相同的新数组，空间复杂度是O(n)O(n)。\n3.3 递归调用栈的空间复杂度（不需要太了解） 递归算法会使用调用栈空间，需要考虑递归深度。\n1 2 3 4 5 int factorial(int n) { if (n \u0026lt;= 1) return 1; return n * factorial(n - 1); } 这个递归算法的空间复杂度是O(n)O(n)，因为递归深度为nn。\n3.4 平方空间复杂度 O(n2)O(n2) 1 2 3 4 5 6 7 8 9 10 11 int[][] createMatrix(int n) { int[][] matrix = new int[n][n]; // 创建一个n×n的矩阵 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { matrix[i][j] = i * j; } } return matrix; } 这个算法创建了一个n×nn×n的矩阵，空间复杂度是O(n2)O(n2)。\n4. 空间复杂度计算示例 示例1: 求和函数 1 2 3 4 5 6 7 8 9 int sum(int n) { int result = 0; // 一个变量 for (int i = 1; i \u0026lt;= n; i++) { result += i; } return result; } 使用的额外空间: 两个整型变量（result和i） 空间复杂度: O(1)O(1) 示例2: 数组复制 1 2 3 4 5 6 7 8 9 int[] copyArray(int arr[], int n) { int[] copy = new int[n]; // 大小为n的新数组 for (int i = 0; i \u0026lt; n; i++) { copy[i] = arr[i]; } return copy; } 使用的额外空间: 一个大小为n的数组和一个整型变量 空间复杂度: O(n)O(n) 示例3: 递归求斐波那契数列 1 2 3 4 5 int fibonacci(int n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } 使用的额外空间: 递归调用栈 递归调用的最大深度: nn 空间复杂度: O(n)O(n) 示例4: 动态规划求斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 int fibonacciDP(int n) { int[] dp = new int[n + 1]; // 大小为n+1的数组 dp[0] = 0; if (n \u0026gt; 0) dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } 使用的额外空间: 一个大小为n+1的数组和一个整型变量 空间复杂度: O(n) ","date":"2025-03-11T00:00:00Z","image":"https://Zq-jw.github.io/p/%E7%AE%97%E6%B3%951%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%85%A5%E9%97%A8/QQ%E5%9B%BE%E7%89%8720221204195959_hu_8fe2a6c8977d948a.jpg","permalink":"https://Zq-jw.github.io/p/%E7%AE%97%E6%B3%951%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%85%A5%E9%97%A8/","title":"算法1：时空复杂度入门"},{"content":"算法基础 1 2 3 ascii常用码值 48 --- 0\t65 --- A\t97 --- a 1、常用正则表达 1.1 元字符、字符集与量词详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 （一）元字符 元字符是正则表达式中的特殊字符，具有特殊含义。常见的元字符包括： . ：匹配除换行符以外的任意单个字符。 ^ ：匹配字符串的开始位置。 $ ：匹配字符串的结束位置。 * ：匹配前面的子表达式零次或多次。 + ：匹配前面的子表达式一次或多次。 ? ：匹配前面的子表达式零次或一次。 {n} ：匹配前面的子表达式恰好 n 次。 {n,m} ：匹配前面的子表达式至少 n 次，至多 m 次。 [] ：定义一个字符集合，匹配其中的任意一个字符。 | ：匹配左边或右边的表达式。 () ：捕获括号内的表达式，形成一个分组。 （二）字符集 字符集用于定义一组字符，匹配其中的任意一个字符。常见的字符集包括： [abc] ：匹配 a、b 或 c。 [a-z] ：匹配小写字母 a 到 z。 [A-Z] ：匹配大写字母 A 到 Z。 [0-9] ：匹配数字 0 到 9。 [a-zA-Z0-9] ：匹配字母或数字。 （三）量词 量词用于指定前面的字符或子表达式出现的次数。常见的量词包括： * ：零次或多次。 + ：一次或多次。 ? ：零次或一次。 {n} ：恰好 n 次。 {n,m} ：至少 n 次，至多 m 次。 1.2 次数表示 2、快速输入输出 2.1 快速输入（StreamTokenizer） ​ StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符（如：~!@#$%^\u0026amp;*()_+{}:\u0026lt;\u0026gt;?)无法识别，会显示null。同时如果要求输出的是字符，你的输入却是数字开头，那么字符会变成null。要求是输入数字你却输出了字母，那么数字会变成0。\n（1）我们在使用StreamTokenizer类时，我们要导入io包，它是io包中的类 （2）在使用这个类时，函数要抛出IOException异常（throws IOException） （3）每一次读入之前都要用nextToken（）方法获取下一个数据 （4）读取数据的方法，sval方法读取字符串类型（以空格或者换行分隔），nval方法读取数字类型数据。读取字符串类型的数据时，一次只能读一个字符串，读取数字类型的数据时，默认为double类型 （5）StreamTokenizer类使用的具体写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.io.*; public class test { public static void main(String args[]) throws IOException{ StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); st.nextToken(); String str = st.sval;//读取String类型数据` st.nextToken(); double num1 = st.nval;//读取double类型数据` st.nextToken(); int num2 = (int)st.nval;//读取int类型数据` st.nextToken(); long num3 = (long)st.nval;//读取long类型数据 } } 2.2 推荐输入方法\u0026mdash;写成内部工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** 快速输入类 */ static class Reader { static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer tokenizer = new StringTokenizer(\u0026#34;\u0026#34;); /** 获取下一段文本 */ static String next() throws IOException { while ( ! tokenizer.hasMoreTokens() ) { tokenizer = new StringTokenizer(reader.readLine()); } return tokenizer.nextToken(); } static int nextInt() throws IOException { return Integer.parseInt( next() ); } static double nextDouble() throws IOException { return Double.parseDouble( next() ); } } 2.3 快速输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.io.IOException; import java.io.OutputStreamWriter; import java.io.PrintWriter; public class PrintWriterOutput { public static void main(String[] args) throws IOException { PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); String str = \u0026#34;这里是要输出的内容!\u0026#34;; out.print(str); // 输出后不换行 out.println(str); // 输出后换行 out.printf(\u0026#34;%s\u0026#34;, str); // 格数化输出 out.flush(); // ！!!!!!!!!!!记得刷新一下在控制台输出 } } 4、常用api 4.1 String 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 返回此字符串的长度 length()\t// 判空，当长度为0时返回true isEmpty() // 除去任何前导和尾随空格，如果该字符串没有前导或尾随的空格，则返回值为该字符串本身 trim()\t// 返回索引i处的字符，也可以通过toCharArray()转变成数组再遍历 charAt(int i)\t// 按字典顺序比较两个字符串 compareTo(String anotherString)\t// 按字典顺序且不区分大小写比较两个字符串 compareToIgnoreCase(String anotherString) // 判断两个字符串是否相等，相等返回true否则返回false equals(String anotherString) // 同上，不区分大小写 equalsIgnoreCase(String str)\t// 检查是否以某一前缀开始 startsWith(String prefix)\t// 根据指定字符串拆分 split(String regex) // 返回从begin开始到end-1结束的子串 substring(int beginIndex, int end)\t// 将此字符串中的所有字母都换为大写 toUpperCase() // 将此字符串中的所有字母都换为小写 toLowerCase()\t// lastIndexOf有类似用法👇 // 返回指定字符在此字符串中第一次出现的索引 indexOf(char ch)\t// 同上，从指定索引开始搜索 indexOf(char ch, int fromindex) // 返回子串在此字符串中第一次出现的索引 indexOf(String str)\t// 同上，从指定索引开始搜索 indexOf(String str, int fromindex)\t// 用s2替换目标字符串中出现的所有s1 replaceAll(String s1,String s2)\t// 用s2替换目标字符串中出现的第一个s1 replaceFirst(String s1,String s2) // 类方法【即String.xxx】 // 返回 char数组的字符串表示形式 valueOf(char[] data)\t// 返回 char 数组参数的特定子数组的字符串表示形式 valueOf(char[] data,int offset,int count) // 返回参数【int,boolean...】的字符串表示形式 valueOf(ele)\t4.2 StringBuilder ​\t相较于String来说，处理速度更快，所以处理字符串的时候一般使用StringBuilder，最后再通过toString()方法转为字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 构建一个值为str的可变字符串【也可传空参数】 StringBuilder(String str) // 返回索引i位置的字符 charAt(int i) // 返回此字符串的长度 length() // 在此字符串追加str【参数为StringBuilder也可以】 append(String str) // 在index处插入字符数组c【c也可以是单个字符或者其他类型】 insert(int index, char[] c)\t// 将char的子数组【下标offset开始，长度len】追加到此字符串 append(char[] str, int offset, int len)\t// 移除此序列从start到end-1的字符串 delete(int start, int end)\t// 移除指定索引上的字符 deleteCharAt(int index)\t// 将指定索引处的字符替换为ch setCharAt(int index, char ch)\t// 将此字符串反转 reverse()\t// 返回此字符串从start开始至length-1结束的String substring(int start)\t// 返回此字符串从start开始至end-1结束的String substring(int start, int end)\t// 返回此序列中的String表示形式 toString()\t// lastIndexOf有类似用法👇 // 返回子字符串第一次出现的索引 indexOf(String str)\t// 同上，从指定位置查找 indexOf(String str, int fromIndex) 4.3 栈和队列 4.3.1栈的常用方法 1 2 3 4 5 6 7 Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 栈顶插入元素 push(ele) // 返回栈顶元素并弹出 pop() //返回栈顶元素但不弹出 peek() 4.3.2队列的常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); // 头插 addFirst(ele)\t// 尾插 addLast(ele) // 获取队列头元素 getFirst()\t// 获取队列尾元素 getLast\t// 获取头元素并弹出 poll()\t// 获取尾元素并弹出 pollLast()\t// 删除指定索引元素 remove(index)\t// 返回首次出现某元素的索引 indexOf(ele)\t4.3.3通用方法 1 2 3 4 5 6 7 8 9 10 // 清空 clear()\t// 返回大小 size()\t// 判断是否为空 isEmpty()\t// 得到指定索引元素【栈是从栈顶数下来】 get(index)\t// 改变某索引处的元素 set(index,ele)\t4.4 链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ArrayList\u0026lt;E\u0026gt; objectName =new ArrayList\u0026lt;\u0026gt;();　// 初始化 // 默认将元素添加到链表尾，可以通过index添加到指定位置 add(ele)\t// 移除指定位置元素 remove(index)\t// 修改指定位置元素 set(index,element)\t// 得到指定位置元素 get(index)\t// 返回第一次/最后一次出现某元素的索引 indexOf/lastIndexOf(ele)\t//返回大小/是否为空 size()/isEmpty()\t// 链表变数组 toArray()\t// 字符串形式输出【若要输出自定义形式，可以遍历后用StringBuilder拼接】 toString() 4.5 集合set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Set\u0026lt;object\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 集合如果不存在元素ele，则添加此元素 add(ele)\t// 清空 clear()\t// 查询指定元素是否存在，存在返回true contains(ele)\t// 判空 isEmpty()\t// 如果指定元素在此set中则移除 remove(ele)\t// 返回元素数量 size()\t// 返回一个大于等于当前元素的最小元素【屋顶上一个】，不存在返回null ceiling(ele)\t// 返回一个小于等于当前元素的最大元素【地板下一个】，不存在返回null floor(ele)\t// 返回此set中严格大于给定元素的最小元素,不存在返回null higher(ele)\t// 返回此set中严格小于给定元素的最大元素，不存在返回null lower(ele)\t// 返回第一个元素 first()\t// 返回最后一个元素 last() 4.6 映射map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 在此映射中关联指定值与指定键 put(key,value)\t// 从此映射中移除指定键的映射关系（如果存在) remove(key)\t// 清空 clear() // 如果包含指定键，返回true containsKey(key)\t// 如果包含指定值，返回true containsValue(value) // 返回指定键的值，如果不存在返回null get(key)\t// 返回此映射中当前第一个（最低）键 firstKey()\t// 返回映射中当前最后一个（最高）键 lastKey()\t// 返回大于等于给定键的最小键；如果不存在这样的键，则返回 null ceilingKey(key)\t// 返回小于等于给定键的最大键；如果不存在这样的键，则返回 null floorKey(key)\t// 是否空/map大小 isEmpty()/size() //查找key = a的value，如果没有返回b getOrDefault(a,b) //获得key值链表 keySet() //遍历 TreeMap\u0026lt;Integer, Integer\u0026gt; map = new TreeMap\u0026lt;Integer,Integer\u0026gt;(); map.put(1, 2); for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;关键字：\u0026#34;+entry.getKey()); System.out.println(\u0026#34;值：\u0026#34;+entry.getValue()); } 4.7 工具类 4.7.1arrays 1 2 3 4 5 6 7 8 9 10 11 12 // 将arr数组元素变为字符串，一般用于输出看看数组情况，省去遍历的繁琐操作 toString(arr) // arr数组排序，可以传入匿名类Comparator自定义排序方式 sort(arr,new Comparator\u0026lt;T\u0026gt;(){}) // arr数组二分查找(需要排好序)元素ele，返回目标值索引，找不到返回-1\tbinarySearch(arr,ele) // 复制arr数组[from,to)位置元素，返回复制好的数组副本 copyOfRange(arr,from,to) // 使用ele元素将数组填充 fill(arr,ele) // 比较两个数组元素的内容是否完全一致 equals(arr1,arr2) 4.7.2Collections 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 仅List可用 // 反转List中的元素 reverse(list) // 按照小到大对链表进行排序【默认】，也可以实现Compartor接口自定义排序 sort(list,new Cpmparator\u0026lt;T\u0026gt;(){}) // 将list中的i处元素和j处元素进行交换 swap(list,i,j) // list2拷贝到list1，要确保list1有足够空间 copy(list1,list2) // 将list中的A替换成B replaceAll(list,A,B)\t// List和Set都可用 // 返回最大、最小元素 max(list)/min(list) // ele出现次数 frequency(list,ele) 4.7.3Integer 1 2 3 4 5 6 7 8 // Boolean，Double等都有类似将字符串转换的方法👇 // 将字符串参数解析为带符号的十进制整数 parseInt(String s) // 将字符串参数解析为第二个参数指定的基数中的有符号正整数 // radix参数不填则默认以十进制数进行解析 parseInt(String s, int radix) // 将i转为k进制真值【有正负号】 toString(int i，k) 4.8 日期Calendar 通过设置对象内部字段再通过get方法获得数值\nYEAR ：指示年份\nMONTH：指示月份\nMONTH字段是从0月开始计数的，所以12月对应的值是11\nDAY_OF_MONTH：指示一个月中的某天。\nDAY_OF_WEEK：指示一个星期中的某天。\nDAY_OF_YEAR：指示当前年中的天数。\nDAY_OF_WEEK_IN_MONTH：指示当前月中的第几个星期。\nHOUR：指示当天中的某小时\nMINUTE：指示当前小时中的某分钟\nSECOND：指示当前分钟中的某秒\n1 2 3 4 5 6 7 8 9 10 11 12 // 得到Calendar对象 Calendar calendar = Calendar.getInstance();\t// 第一个参数是日期字段，诸如YEAR、MONTH等将给定的日历字段设置为给定值 set(int field, int value) // 设置日历字段年月日的值 set(int year, int month, int day) // 获取给定字段的值 get(int field);\t// 以毫秒为单位返回日历时间值 getTimeInMillis() // 根据日历的规则，为给定的日历字段添加或减去指定的时间量 add(int field, int amount) 4.9 数学工具Math 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // a,b的最值 min(a,b)/max(a,b) // 返回正确舍入的 double 值的正平方根 sqrt(double a)\t// 绝对值 abs(a)\t// a的b次方，返回一个double类型的数。 pow(double a, double b) // 向上取整 ceil(double x)\t// 向下取整 floor(double x)\t// 四舍五入取整 round(double x)\t// 生成一个[0,1)之间的double类型的伪随机数 random()\t// tan，cos与sin类似 // acos(-1)=π // 正弦值 sin(double a) // 反正弦值 asin(double a) 4.10 大数类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 传入字符串参数直接创建，可以使用=进行同类型赋值 BigInteger a = new BigInteger(\u0026#34;123456789101112131415\u0026#34;); BigDecimal c = new BigDecimal(\u0026#34;123456.123456\u0026#34;); // 以二进制解析\u0026#34;111110\u0026#34;，变为10进制赋值给d BigInteger d = new BigInteger(\u0026#34;111110\u0026#34;, 2);\t// 把a转化为16进制的字符串输出 System.out.println(a.toString(16));\t// a对象值+b对象值并将结果返回 a.add(b) // 减法，同上👆 a.subtract(b) // 乘法，同上 a.multiply(b) // 除法，同上 a.divide(b) // 取余，同上 a.mod(b) // 最大公因数，同上 a.gcd(b)\t// 最值，同上 a.max(b)/a.min(b)\t// a的b次方 a.pow(b) // 比较大小，a大返回1 a.compareTo(b) // 把BigInteger 转化为 BigDecimal toBigDecimal() // 把BigDecimal 转化为 BigInteger toBigInteger() `BigDecimal`在乘除时可以指定结果舍入方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 只有乘除法才有舍入这个说法 // 向零舍入。 即1.55 变为 1.5 , -1.55 变为-1.5 ROUND_DOWN // 向正无穷舍入. 即 1.55 变为 1.6 , -1.55 变为 -1.5 ROUND_CEILING // 向负无穷舍入. 即 1.55 变为 1.5 , -1.55 变为 -1.6 ROUND_FLOOR // 四舍五入 即1.55 变为1.6, -1.55变为-1.6 ROUND_HALF_UP // 五舍六入 即 1.55 变为 1.5, -1.5变为-1.5 ROUND_HALF_DOWN // a除b结果四舍五入并保留两位小数返回给c BigDecimal c = a.divide(b, 2, BigDecimal.ROUND_HALF_UP); // a保留两位小数并且向0舍入 a = a.setScale(2, BigDecimal.ROUND_DOWN); 4.11 常用封装算法 4.11.1最大公因数/最小公倍数 1 2 3 4 5 6 7 8 9 // 最大公约数，此法原理为欧几里得算法，可以理解为是发现的一个规律，不必深究 int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); } // 最小公倍数=两数之积/两数最大公约数 int lcm(int a, int b) { return a * b / gcd(a, b); } 4.11.2快速幂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 快速幂 static int qmi(int a, int b) { // 保存结果 int res = 1;\twhile (b != 0) { if ((b \u0026amp; 1) == 1) {\t// 当前最右边二进制位上有值时，说明当前a值是我们所需要的 res = res * a; } // b每次处理完一位后往右移 b = b \u0026gt;\u0026gt; 1;\t// b完成一次位移后，a的次方数应当*2才能满足下一次乘数的要求 a = a * a;\t} return res; } 4.11.3 快速幂求模 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 原理：(a*c)%mode==((a%mode)*(c%mode))%mode // 此函数是求(a^b)%mode static long Mode(long a, long b, long mode) { long sum = 1; a = a % mode; while (b \u0026gt; 0) { if ((b \u0026amp; 1) == 1) { sum = (sum * a) % mode; } b = b \u0026gt;\u0026gt; 1; a = (a * a) % mode; } return sum; } 5、进制转化 5.1 十进制转其他进制 ​\t一个重要的函数：Integer.toString(k,r) ，将十进制的数k转换为r进制的数。返回一个String。\n1 2 3 4 5 6 7 8 9 10 11 int k = 17; System.out.println(Integer.toBinaryString(k)); //转二进制 System.out.println(Integer.toOctalString(k)); //转八进制 System.out.println(Integer.toHexString(k)); //转十六进制 int r =2; System.out.println(Integer.toString(k,r)); //转r进制 r=8; System.out.println(Integer.toString(k,r)); //转r进制 r=16; System.out.println(Integer.toString(k,r)); //转r进制 5.2 其他进制转十进制 ​\t函数：Integer.parseInt(str,r) ，将r进制的数字字符串str转换为十进制，并返回十进制的数。\n1 2 3 4 5 6 7 8 System.out.println(Integer.parseInt(\u0026#34;10001\u0026#34;,2)); System.out.println(Integer.parseInt(\u0026#34;21\u0026#34;,8)); System.out.println(Integer.parseInt(\u0026#34;11\u0026#34;,16)); //输出结果 17 17 17 6、位运算技巧 6.1 利用或操作 | 和空格将英文字符转换为小写 1 2 (\u0026#39;a\u0026#39; | \u0026#39; \u0026#39;) = \u0026#39;a\u0026#39; (\u0026#39;A\u0026#39; | \u0026#39; \u0026#39;) = \u0026#39;a\u0026#39; 6.2 利用与操作 \u0026amp; 和下划线将英文字符转换为大写 1 2 (\u0026#39;b\u0026#39; \u0026amp; \u0026#39;_\u0026#39;) = \u0026#39;B\u0026#39; (\u0026#39;B\u0026#39; \u0026amp; \u0026#39;_\u0026#39;) = \u0026#39;B\u0026#39; 6.3 利用异或操作 ^ 和空格进行英文字符大小写互换 1 2 (\u0026#39;d\u0026#39; ^ \u0026#39; \u0026#39;) = \u0026#39;D\u0026#39; (\u0026#39;D\u0026#39; ^ \u0026#39; \u0026#39;) = \u0026#39;d\u0026#39; 7、图的存储 7.1 邻接矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Main { public static int maxd = 1000+7; public static void main(String[] args) throws Exception { int[][] G = new int[maxd][maxd]; int n = nextInt(); //n个点 int m = nextInt(); //m条边 while(m--\u0026gt;0) { int a = nextInt(); //a点（起点） int b = nextInt(); //b点（终点） int c = nextInt(); //边的权重 //有向图 //G[a][b] = c; //a-\u0026gt;b // 无向图 G[a][b] = c; //a-\u0026gt;b G[b][a] = c; //b-\u0026gt;a } for(int i=1;i\u0026lt;=n;++i) { for(int j=1;j\u0026lt;=n;++j) { System.out.print(G[i][j]); } System.out.println(); } closeAll();\t} } 7.2 邻接表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static void main(String[] args) throws Exception { int n = nextInt(); //n个点 int m = nextInt(); //m条边 ArrayList[] list = new ArrayList[maxd]; for(int i=1;i\u0026lt;=n;++i) { list[i]= new ArrayList\u0026lt;Integer\u0026gt;(); } while(m--\u0026gt;0) { int a = nextInt(); //a点（起点） int b = nextInt(); //b点（终点） list[a].add(b); list[b].add(a); } for(int i=1;i\u0026lt;=n;++i) { int len = list[i].size(); System.out.print(i+\u0026#34; \u0026#34;); for(int j=0;j\u0026lt;len;++j) { System.out.print(\u0026#34; -\u0026gt; \u0026#34;+list[i].get(j)); } System.out.println(); } } ","date":"2025-03-11T00:00:00Z","image":"https://Zq-jw.github.io/p/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80java/14f13872a196ca3560305c6654f929e_hu_23b11846bd03f065.jpg","permalink":"https://Zq-jw.github.io/p/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80java/","title":"算法基础（java）"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Zq-jw.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://Zq-jw.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Zq-jw.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://Zq-jw.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://Zq-jw.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://Zq-jw.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Zq-jw.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Zq-jw.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://Zq-jw.github.io/p/emoji-support/","title":"Emoji Support"}]